var N=null,E="",T="t",U="u",searchIndex={};
var R=["Special","clarith","reduction","number","result","try_from","try_into","borrow_mut","borrow","type_id","clarith::protocol","typeid","formatter","Reduction"];

searchIndex["clarith"]={"doc":"Continued Logarithm Arithmetic","i":[[3,"Clog",R[1],"A number greater than zero and lesser than one with…",N,N],[4,"Number",E,"A finite unbounded number with unbounded precision.",N,N],[13,R[0],E,E,0,N],[13,"Other",E,E,0,N],[0,"protocol",E,"This module defines the required symbols for expressing…",N,N],[4,R[13],R[10],"The Reduction enum defines the symbols that allow any…",N,N],[13,"Amplify",E,"The value was greater than zero and lesser than one half,…",1,N],[13,"Uncover",E,"The value was greater than one half and lesser than one,…",1,N],[4,"Primer",E,"The Primer enum defines transformations that can be…",N,N],[13,"Turn",E,"The value was reciprocated.",2,N],[13,"Reflect",E,"The value was negated.",2,N],[13,"Ground",E,"The value was reciprocated and negated.",2,N],[4,R[0],E,"Values that cannot be represented by the combination of an…",N,N],[13,"NegOne",E,"The value is minus one.",3,N],[13,"Zero",E,"The value is zero.",3,N],[13,"PosOne",E,"The value is one.",3,N],[11,"egest",R[1],"Destructively extract the next Reduction symbol from self.…",4,[[["self"]],[["option",[R[2]]],[R[2]]]]],[11,"unwrap_special",E,"Unwraps the Special content from self, or panic.",0,[[],["special"]]],[11,"unwrap_other",E,"Unwraps the Other content from self, or panic.",0,[[]]],[11,"compare",E,"Destructively compare two Numbers.",0,[[[R[3]]],["ordering"]]],[11,"ratio",E,"Construct a Number from the ratio of two signed machine…",0,[[["isize"]],[R[3]]]],[11,"ratio_u",E,"Construct a Number from the ratio of two unsigned machine…",0,[[["usize"],["bool"]],[R[3]]]],[11,"homographic",E,"Construct the Number (nx * x + n) / (dx * x + d)",0,[[["isize"],[R[3]]],[R[3]]]],[11,"combine",E,"Construct the Number (nxy * x * y + nx * x + ny * y + n) /…",0,[[["isize"],[R[3]]],[R[3]]]],[11,"consume",E,"Transfer information from a Number to a homograhic…",0,[[[R[3]]]]],[11,"into",E,E,4,[[],[U]]],[11,"from",E,E,4,[[[T]],[T]]],[11,R[5],E,E,4,[[[U]],[R[4]]]],[11,R[6],E,E,4,[[],[R[4]]]],[11,R[7],E,E,4,[[["self"]],[T]]],[11,R[8],E,E,4,[[["self"]],[T]]],[11,R[9],E,E,4,[[["self"]],[R[11]]]],[11,"into",E,E,0,[[],[U]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[5],E,E,0,[[[U]],[R[4]]]],[11,R[6],E,E,0,[[],[R[4]]]],[11,R[7],E,E,0,[[["self"]],[T]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[R[11]]]],[11,"into",R[10],E,1,[[],[U]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[5],E,E,1,[[[U]],[R[4]]]],[11,R[6],E,E,1,[[],[R[4]]]],[11,R[7],E,E,1,[[["self"]],[T]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[R[11]]]],[11,"into",E,E,2,[[],[U]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[5],E,E,2,[[[U]],[R[4]]]],[11,R[6],E,E,2,[[],[R[4]]]],[11,R[7],E,E,2,[[["self"]],[T]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[R[11]]]],[11,"into",E,E,3,[[],[U]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[5],E,E,3,[[[U]],[R[4]]]],[11,R[6],E,E,3,[[],[R[4]]]],[11,R[7],E,E,3,[[["self"]],[T]]],[11,R[8],E,E,3,[[["self"]],[T]]],[11,R[9],E,E,3,[[["self"]],[R[11]]]],[11,"eq",E,E,1,[[["self"],[R[2]]],["bool"]]],[11,"eq",E,E,2,[[["self"],["primer"]],["bool"]]],[11,"eq",E,E,3,[[["self"],["special"]],["bool"]]],[11,"fmt",E,E,1,[[["self"],[R[12]]],[R[4]]]],[11,"fmt",E,E,2,[[["self"],[R[12]]],[R[4]]]],[11,"fmt",E,E,3,[[["self"],[R[12]]],[R[4]]]]],"p":[[4,"Number"],[4,R[13]],[4,"Primer"],[4,R[0]],[3,"Clog"]]};
initSearch(searchIndex);addSearchOptions(searchIndex);